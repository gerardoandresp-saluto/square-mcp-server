import fetch from 'node-fetch';
import { ApiMethodInfo, ApiParameter } from '../api-types.js';
import FormData from 'form-data';
import { baseUrl, apiVersion, getRequestHeaders, handleResponse } from '../config.js';
import * as fs from 'fs';
import * as path from 'path';
import { typeMap } from '../utils/type-map.js';

/**
 * Method information for each API endpoint
 */
export const MerchantsMethods: { [key: string]: ApiMethodInfo } = {
  list: {
    description: "The access token used to connect your application to a Square seller is associated\nwith a single merchant. That means that `ListMerchants` returns a list\nwith a single `Merchant` object. You can specify your personal access token\nto get your own merchant information or specify an OAuth token to get the\ninformation for the merchant that granted your application access.\n\nIf you know the merchant ID, you can also use the [RetrieveMerchant](api-endpoint:Merchants-RetrieveMerchant)\nendpoint to retrieve the merchant information.",
    method: "get",
    path: "/v2/merchants",
    pathParams: [],
    queryParams: [{"name":"cursor","type":"integer","description":"The cursor generated by the previous response."}],
    requestType: "ListMerchantsRequest",
    isMultipart: false,
    originalName: "ListMerchants",
    isWrite: false
  } as ApiMethodInfo,

  get: {
    description: "Merchants RetrieveMerchant operation",
    method: "get",
    path: "/v2/merchants/{merchant_id}",
    pathParams: [{"name":"merchant_id","type":"string","description":"The ID of the merchant to retrieve. If the string \"me\" is supplied as the ID,\nthen retrieve the merchant that is currently accessible to this call."}],
    queryParams: [],
    requestType: "RetrieveMerchantRequest",
    isMultipart: false,
    originalName: "RetrieveMerchant",
    isWrite: false
  } as ApiMethodInfo
};

/**
 * Handlers for each API endpoint
 */
export const MerchantsHandlers = {
  get: async (accessToken: string, args: Record<string, unknown>) => {
    const methodInfo = MerchantsMethods.get;
    
    // Extract path parameters
    const pathParams: Record<string, string> = {};
    methodInfo.pathParams.forEach(param => {
      const value = args[param.name];
      if (value !== undefined) {
        pathParams[param.name] = String(value);
        delete args[param.name];
      } else if (param.required) {
        throw new Error(`Missing required path parameter: ${param.name}`);
      }
    });

    // Build URL with path parameters
    let url = methodInfo.path;
    
    // Replace path parameters
    Object.entries(pathParams).forEach(([key, value]) => {
      url = url.replace(`{${key}}`, encodeURIComponent(value));
    });

    // Make regular JSON request
    const response = await fetch(`${baseUrl}${url}`, {
      method: methodInfo.method.toUpperCase(),
      headers: getRequestHeaders(accessToken),
      ...(Object.keys(args).length > 0 && ['post', 'put', 'patch'].includes(methodInfo.method.toLowerCase()) && { body: JSON.stringify(args) })
    });
    return await handleResponse(response)
  },

  list: async (accessToken: string, args: Record<string, unknown>) => {
    const methodInfo = MerchantsMethods.list;
    
    // Extract query parameters
    const queryParams: Record<string, string> = {};
    methodInfo.queryParams.forEach(param => {
      const value = args[param.name];
      if (value !== undefined) {
        queryParams[param.name] = String(value);
        delete args[param.name];
      }
    });

    // Build URL with query parameters
    let url = methodInfo.path;
    
    // Add query parameters
    const queryString = Object.entries(queryParams)
      .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
      .join('&');
    if (queryString) {
      url = `${url}?${queryString}`;
    }

    // Make regular JSON request
    const response = await fetch(`${baseUrl}${url}`, {
      method: methodInfo.method.toUpperCase(),
      headers: getRequestHeaders(accessToken),
      ...(Object.keys(args).length > 0 && ['post', 'put', 'patch'].includes(methodInfo.method.toLowerCase()) && { body: JSON.stringify(args) })
    });
    return await handleResponse(response)
  }
};